/**
 * Business Intelligence System
 * 
 * Advanced BI system for blood donation analytics with automated reporting,
 * data mining, and strategic insights generation
 */

import { getAnalyticsEngine, AnalyticsQuery, AnalyticsResult } from './analytics-engine'
import { getMLPipelineAPI } from '../ai/ml-pipeline/ml-pipeline-api'
import { getOptimizedDB } from '../database/optimized-queries'
import { getCache } from '../cache/redis-cache'
import { performanceMonitor } from '../performance/metrics'

export interface BIReport {
  id: string
  name: string
  description: string
  category: 'operational' | 'strategic' | 'financial' | 'clinical' | 'regulatory'
  type: 'scheduled' | 'ad_hoc' | 'real_time' | 'alert'
  schedule?: {
    frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly'
    time: string // HH:MM format
    timezone: string
    recipients: string[]
  }
  queries: AnalyticsQuery[]
  template: {
    format: 'pdf' | 'excel' | 'html' | 'json'
    layout: 'executive' | 'detailed' | 'dashboard' | 'custom'
    sections: Array<{
      id: string
      title: string
      type: 'chart' | 'table' | 'kpi' | 'text' | 'insights'
      config: Record<string, any>
    }>
  }
  filters: {
    dateRange: { start: Date; end: Date }
    regions?: string[]
    bloodTypes?: string[]
    userRoles?: string[]
    customFilters?: Record<string, any>
  }
  isActive: boolean
  lastGenerated?: Date
  nextScheduled?: Date
}

export interface BIInsight {
  id: string
  type: 'trend' | 'anomaly' | 'correlation' | 'prediction' | 'recommendation'
  category: string
  title: string
  description: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  confidence: number
  data: {
    metrics: Record<string, number>
    visualizations: Array<{
      type: string
      config: Record<string, any>
      data: any[]
    }>
    supporting_evidence: string[]
  }
  actionItems: Array<{
    priority: 'low' | 'medium' | 'high' | 'critical'
    action: string
    owner: string
    deadline: Date
    impact: string
  }>
  createdAt: Date
  expiresAt?: Date
}

export interface DataMiningJob {
  id: string
  name: string
  type: 'pattern_discovery' | 'anomaly_detection' | 'clustering' | 'classification' | 'association_rules'
  status: 'pending' | 'running' | 'completed' | 'failed'
  config: {
    dataSource: string
    algorithm: string
    parameters: Record<string, any>
    outputFormat: string
  }
  results?: {
    patterns: any[]
    insights: BIInsight[]
    confidence: number
    executionTime: number
  }
  createdAt: Date
  completedAt?: Date
  error?: string
}

export interface StrategicMetric {
  id: string
  name: string
  description: string
  category: 'growth' | 'efficiency' | 'quality' | 'sustainability' | 'innovation'
  calculation: {
    formula: string
    dependencies: string[]
    updateFrequency: 'real_time' | 'hourly' | 'daily' | 'weekly'
  }
  targets: {
    current: number
    target: number
    benchmark: number
    timeframe: string
  }
  trends: {
    direction: 'up' | 'down' | 'stable'
    velocity: number
    acceleration: number
    seasonality: boolean
  }
  lastUpdated: Date
}

class BusinessIntelligenceSystem {
  private analyticsEngine = getAnalyticsEngine()
  private mlPipeline = getMLPipelineAPI()
  private db = getOptimizedDB()
  private cache = getCache()
  
  private reports: Map<string, BIReport> = new Map()
  private insights: Map<string, BIInsight> = new Map()
  private dataMiningJobs: Map<string, DataMiningJob> = new Map()
  private strategicMetrics: Map<string, StrategicMetric> = new Map()

  // Configuration
  private readonly CONFIG = {
    maxConcurrentJobs: 10,
    insightRetentionDays: 30,
    reportCacheTTL: 3600, // 1 hour
    anomalyThreshold: 2.5,
    correlationThreshold: 0.7,
    predictionHorizonDays: 90,
    autoInsightGeneration: true
  }

  // Strategic KPIs for blood donation system
  private readonly STRATEGIC_METRICS: StrategicMetric[] = [
    {
      id: 'donor_lifetime_value',
      name: 'Donor Lifetime Value',
      description: 'Average value generated by a donor over their lifetime',
      category: 'growth',
      calculation: {
        formula: 'AVG(total_donations * avg_units_per_donation * unit_value)',
        dependencies: ['donations', 'donor_profiles'],
        updateFrequency: 'daily'
      },
      targets: {
        current: 0,
        target: 500,
        benchmark: 400,
        timeframe: 'annual'
      },
      trends: {
        direction: 'stable',
        velocity: 0,
        acceleration: 0,
        seasonality: false
      },
      lastUpdated: new Date()
    },
    {
      id: 'supply_chain_efficiency',
      name: 'Supply Chain Efficiency',
      description: 'Efficiency of blood collection to distribution process',
      category: 'efficiency',
      calculation: {
        formula: '(successful_distributions / total_collections) * (1 - wastage_rate)',
        dependencies: ['collections', 'distributions', 'inventory'],
        updateFrequency: 'daily'
      },
      targets: {
        current: 0,
        target: 0.95,
        benchmark: 0.90,
        timeframe: 'monthly'
      },
      trends: {
        direction: 'stable',
        velocity: 0,
        acceleration: 0,
        seasonality: true
      },
      lastUpdated: new Date()
    }
  ]

  constructor() {
    this.initializeStrategicMetrics()
    this.initializeDefaultReports()
    this.startAutomatedProcesses()
  }

  async generateReport(reportId: string, customFilters?: Record<string, any>): Promise<{
    report: any
    metadata: {
      generatedAt: Date
      executionTime: number
      dataFreshness: Date
      recordCount: number
    }
  }> {
    const startTime = performance.now()

    try {
      const reportConfig = this.reports.get(reportId)
      if (!reportConfig) {
        throw new Error(`Report ${reportId} not found`)
      }

      // Check cache first
      const cacheKey = `bi_report:${reportId}:${JSON.stringify(customFilters || {})}`
      const cachedReport = await this.cache.get(cacheKey)
      
      if (cachedReport) {
        return cachedReport
      }

      // Execute all queries for the report
      const queryResults: AnalyticsResult[] = []
      let totalRecords = 0

      for (const query of reportConfig.queries) {
        const enhancedQuery = {
          ...query,
          filters: { ...query.filters, ...reportConfig.filters, ...customFilters }
        }

        const result = await this.analyticsEngine.executeQuery(enhancedQuery)
        queryResults.push(result)
        totalRecords += result.metadata.totalRecords
      }

      // Generate insights for the report
      const reportInsights = await this.generateReportInsights(queryResults, reportConfig)

      // Build report structure
      const report = await this.buildReport(reportConfig, queryResults, reportInsights)

      const metadata = {
        generatedAt: new Date(),
        executionTime: performance.now() - startTime,
        dataFreshness: new Date(),
        recordCount: totalRecords
      }

      const result = { report, metadata }

      // Cache the report
      await this.cache.set(cacheKey, result, { 
        ttl: this.CONFIG.reportCacheTTL,
        tags: ['bi_report', reportConfig.category]
      })

      // Record metrics
      this.recordReportMetrics(reportConfig, metadata)

      // Update last generated timestamp
      reportConfig.lastGenerated = new Date()
      this.reports.set(reportId, reportConfig)

      return result

    } catch (error) {
      const executionTime = performance.now() - startTime
      
      performanceMonitor.recordCustomMetric({
        name: 'bi_report_generation_duration',
        value: executionTime,
        unit: 'ms',
        timestamp: Date.now(),
        tags: {
          success: 'false',
          report_id: reportId,
          error: (error as Error).message
        }
      })

      throw new Error(`Report generation failed: ${(error as Error).message}`)
    }
  }

  async generateInsights(category?: string, timeRange?: { start: Date; end: Date }): Promise<BIInsight[]> {
    try {
      const insights: BIInsight[] = []

      // Generate trend insights
      const trendInsights = await this.generateTrendInsights(timeRange)
      insights.push(...trendInsights)

      // Generate anomaly insights
      const anomalyInsights = await this.generateAnomalyInsights(timeRange)
      insights.push(...anomalyInsights)

      // Generate correlation insights
      const correlationInsights = await this.generateCorrelationInsights(timeRange)
      insights.push(...correlationInsights)

      // Generate predictive insights
      const predictiveInsights = await this.generatePredictiveInsights(timeRange)
      insights.push(...predictiveInsights)

      // Filter by category if specified
      const filteredInsights = category 
        ? insights.filter(insight => insight.category === category)
        : insights

      // Store insights
      for (const insight of filteredInsights) {
        this.insights.set(insight.id, insight)
      }

      return filteredInsights

    } catch (error) {
      throw new Error(`Insight generation failed: ${(error as Error).message}`)
    }
  }

  async startDataMiningJob(config: Omit<DataMiningJob, 'id' | 'status' | 'createdAt'>): Promise<string> {
    if (this.dataMiningJobs.size >= this.CONFIG.maxConcurrentJobs) {
      throw new Error('Maximum concurrent data mining jobs reached')
    }

    const jobId = `mining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    const job: DataMiningJob = {
      id: jobId,
      status: 'pending',
      createdAt: new Date(),
      ...config
    }

    this.dataMiningJobs.set(jobId, job)

    // Start job execution
    this.executeDataMiningJob(jobId).catch(error => {
      console.error(`Data mining job ${jobId} failed:`, error)
      job.status = 'failed'
      job.error = error.message
    })

    return jobId
  }

  private async executeDataMiningJob(jobId: string): Promise<void> {
    const job = this.dataMiningJobs.get(jobId)
    if (!job) return

    job.status = 'running'

    try {
      const startTime = performance.now()

      // Execute data mining based on type
      let results: DataMiningJob['results']

      switch (job.type) {
        case 'pattern_discovery':
          results = await this.executePatternDiscovery(job.config)
          break
        case 'anomaly_detection':
          results = await this.executeAnomalyDetection(job.config)
          break
        case 'clustering':
          results = await this.executeClustering(job.config)
          break
        case 'classification':
          results = await this.executeClassification(job.config)
          break
        case 'association_rules':
          results = await this.executeAssociationRules(job.config)
          break
        default:
          throw new Error(`Unsupported data mining type: ${job.type}`)
      }

      job.results = {
        ...results,
        executionTime: performance.now() - startTime
      }

      job.status = 'completed'
      job.completedAt = new Date()

      // Store insights from data mining
      if (results.insights) {
        for (const insight of results.insights) {
          this.insights.set(insight.id, insight)
        }
      }

    } catch (error) {
      job.status = 'failed'
      job.error = (error as Error).message
    }
  }

  private async executePatternDiscovery(config: DataMiningJob['config']): Promise<DataMiningJob['results']> {
    // Implement pattern discovery algorithm
    const query: AnalyticsQuery = {
      id: 'pattern_discovery',
      name: 'Pattern Discovery Query',
      type: 'dimension',
      timeRange: {
        start: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000), // 90 days
        end: new Date(),
        granularity: 'day'
      },
      filters: {},
      groupBy: ['blood_type', 'region', 'day_of_week']
    }

    const result = await this.analyticsEngine.executeQuery(query)
    
    // Analyze patterns in the data
    const patterns = this.analyzePatterns(result.data)
    
    return {
      patterns,
      insights: this.generatePatternInsights(patterns),
      confidence: 0.8
    }
  }

  private async executeAnomalyDetection(config: DataMiningJob['config']): Promise<DataMiningJob['results']> {
    // Use ML pipeline for anomaly detection
    const mlResult = await this.mlPipeline.processRequest({
      type: 'ensemble',
      data: {
        features: {
          donation_count: 1,
          avg_response_time: 1,
          success_rate: 1,
          seasonal_factor: 1
        },
        predictionType: 'supply_risk',
        includeExplanation: true
      }
    })

    const anomalies = this.detectAnomaliesFromML(mlResult)
    
    return {
      patterns: anomalies,
      insights: this.generateAnomalyInsights(),
      confidence: mlResult.ensemblePrediction?.confidence || 0.7
    }
  }

  private async executeClustering(config: DataMiningJob['config']): Promise<DataMiningJob['results']> {
    // Implement clustering algorithm (simplified)
    const query: AnalyticsQuery = {
      id: 'clustering_data',
      name: 'Clustering Data Query',
      type: 'dimension',
      timeRange: {
        start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
        end: new Date(),
        granularity: 'day'
      },
      filters: {}
    }

    const result = await this.analyticsEngine.executeQuery(query)
    const clusters = this.performClustering(result.data)
    
    return {
      patterns: clusters,
      insights: this.generateClusterInsights(clusters),
      confidence: 0.75
    }
  }

  private async executeClassification(config: DataMiningJob['config']): Promise<DataMiningJob['results']> {
    // Use ML pipeline for classification
    const mlResult = await this.mlPipeline.processRequest({
      type: 'ensemble',
      data: {
        features: config.parameters,
        predictionType: 'donor_response',
        includeExplanation: true
      }
    })

    return {
      patterns: [mlResult.ensemblePrediction],
      insights: [],
      confidence: mlResult.ensemblePrediction?.confidence || 0.8
    }
  }

  private async executeAssociationRules(config: DataMiningJob['config']): Promise<DataMiningJob['results']> {
    // Implement association rule mining
    const associations = await this.findAssociationRules()
    
    return {
      patterns: associations,
      insights: this.generateAssociationInsights(associations),
      confidence: 0.7
    }
  }

  // Helper methods for data mining
  private analyzePatterns(data: any[]): any[] {
    // Simplified pattern analysis
    const patterns: any[] = []
    
    // Group by blood type and analyze trends
    const bloodTypeGroups = this.groupBy(data, 'blood_type')
    
    for (const [bloodType, records] of Object.entries(bloodTypeGroups)) {
      const trend = this.calculateTrend(records as any[])
      if (Math.abs(trend) > 0.1) { // Significant trend
        patterns.push({
          type: 'trend',
          bloodType,
          trend,
          significance: Math.abs(trend)
        })
      }
    }

    return patterns
  }

  private groupBy(array: any[], key: string): Record<string, any[]> {
    return array.reduce((groups, item) => {
      const group = item[key] || 'unknown'
      groups[group] = groups[group] || []
      groups[group].push(item)
      return groups
    }, {})
  }

  private calculateTrend(data: any[]): number {
    if (data.length < 2) return 0
    
    const values = data.map(d => d.count || d.value || 0)
    const first = values[0]
    const last = values[values.length - 1]
    
    return first > 0 ? (last - first) / first : 0
  }

  private performClustering(data: any[]): any[] {
    // Simplified k-means clustering implementation
    // In production, would use more sophisticated algorithms
    return [
      { cluster: 'high_activity', members: data.filter(d => (d.count || 0) > 100) },
      { cluster: 'medium_activity', members: data.filter(d => (d.count || 0) > 50 && (d.count || 0) <= 100) },
      { cluster: 'low_activity', members: data.filter(d => (d.count || 0) <= 50) }
    ]
  }

  private async findAssociationRules(): Promise<any[]> {
    // Simplified association rule mining
    return [
      {
        antecedent: ['blood_type:O+', 'region:Lagos'],
        consequent: ['high_response_rate'],
        confidence: 0.85,
        support: 0.3,
        lift: 1.2
      }
    ]
  }

  // Insight generation methods
  private generatePatternInsights(patterns: any[]): BIInsight[] {
    return patterns.map(pattern => ({
      id: `pattern_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: 'trend' as const,
      category: 'operational',
      title: `${pattern.bloodType} Blood Type Trend`,
      description: `Detected ${pattern.trend > 0 ? 'increasing' : 'decreasing'} trend in ${pattern.bloodType} donations`,
      severity: pattern.significance > 0.3 ? 'high' : pattern.significance > 0.1 ? 'medium' : 'low',
      confidence: pattern.significance,
      data: {
        metrics: { trend: pattern.trend, significance: pattern.significance },
        visualizations: [],
        supporting_evidence: [`Trend analysis of ${pattern.bloodType} donations`]
      },
      actionItems: [],
      createdAt: new Date()
    }))
  }

  private async generateTrendInsights(timeRange?: { start: Date; end: Date }): Promise<BIInsight[]> {
    // Implementation for trend insights
    return []
  }

  private async generateAnomalyInsights(timeRange?: { start: Date; end: Date }): Promise<BIInsight[]> {
    // Implementation for anomaly insights
    return []
  }

  private async generateCorrelationInsights(timeRange?: { start: Date; end: Date }): Promise<BIInsight[]> {
    // Implementation for correlation insights
    return []
  }

  private async generatePredictiveInsights(timeRange?: { start: Date; end: Date }): Promise<BIInsight[]> {
    // Implementation for predictive insights
    return []
  }

  private generateClusterInsights(clusters: any[]): BIInsight[] {
    return []
  }

  private generateAssociationInsights(associations: any[]): BIInsight[] {
    return []
  }

  private detectAnomaliesFromML(mlResult: any): any[] {
    return []
  }

  private async generateReportInsights(queryResults: AnalyticsResult[], reportConfig: BIReport): Promise<BIInsight[]> {
    // Generate insights specific to the report
    return []
  }

  private async buildReport(config: BIReport, queryResults: AnalyticsResult[], insights: BIInsight[]): Promise<any> {
    // Build the actual report structure
    return {
      id: config.id,
      name: config.name,
      category: config.category,
      sections: config.template.sections.map(section => ({
        ...section,
        data: this.getSectionData(section, queryResults, insights)
      })),
      insights,
      summary: this.generateReportSummary(queryResults, insights)
    }
  }

  private getSectionData(section: any, queryResults: AnalyticsResult[], insights: BIInsight[]): any {
    // Get data for specific report section
    return queryResults[0]?.data || []
  }

  private generateReportSummary(queryResults: AnalyticsResult[], insights: BIInsight[]): any {
    return {
      totalRecords: queryResults.reduce((sum, result) => sum + result.metadata.totalRecords, 0),
      insightCount: insights.length,
      criticalInsights: insights.filter(i => i.severity === 'critical').length
    }
  }

  private recordReportMetrics(config: BIReport, metadata: any): void {
    performanceMonitor.recordCustomMetric({
      name: 'bi_report_generation_duration',
      value: metadata.executionTime,
      unit: 'ms',
      timestamp: Date.now(),
      tags: {
        success: 'true',
        report_id: config.id,
        category: config.category,
        record_count: metadata.recordCount.toString()
      }
    })
  }

  private initializeStrategicMetrics(): void {
    for (const metric of this.STRATEGIC_METRICS) {
      this.strategicMetrics.set(metric.id, metric)
    }
  }

  private initializeDefaultReports(): void {
    // Initialize default BI reports
    const executiveReport: BIReport = {
      id: 'executive_summary',
      name: 'Executive Summary Report',
      description: 'High-level overview of blood donation operations',
      category: 'strategic',
      type: 'scheduled',
      schedule: {
        frequency: 'weekly',
        time: '09:00',
        timezone: 'Africa/Lagos',
        recipients: ['admin@bloodlink.africa']
      },
      queries: [],
      template: {
        format: 'pdf',
        layout: 'executive',
        sections: []
      },
      filters: {
        dateRange: {
          start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
          end: new Date()
        }
      },
      isActive: true
    }

    this.reports.set(executiveReport.id, executiveReport)
  }

  private startAutomatedProcesses(): void {
    // Start automated insight generation
    if (this.CONFIG.autoInsightGeneration) {
      setInterval(async () => {
        try {
          await this.generateInsights()
        } catch (error) {
          console.error('Automated insight generation failed:', error)
        }
      }, 60 * 60 * 1000) // Every hour
    }
  }

  // Public API methods
  public async getInsights(category?: string, severity?: string): Promise<BIInsight[]> {
    let insights = Array.from(this.insights.values())
    
    if (category) {
      insights = insights.filter(insight => insight.category === category)
    }
    
    if (severity) {
      insights = insights.filter(insight => insight.severity === severity)
    }
    
    return insights.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
  }

  public async getDataMiningJob(jobId: string): Promise<DataMiningJob | undefined> {
    return this.dataMiningJobs.get(jobId)
  }

  public async listReports(): Promise<BIReport[]> {
    return Array.from(this.reports.values()).filter(r => r.isActive)
  }

  public getSystemStats() {
    return {
      reports: this.reports.size,
      insights: this.insights.size,
      dataMiningJobs: this.dataMiningJobs.size,
      strategicMetrics: this.strategicMetrics.size
    }
  }
}

// Singleton instance
let businessIntelligenceInstance: BusinessIntelligenceSystem | null = null

export function getBusinessIntelligenceSystem(): BusinessIntelligenceSystem {
  if (!businessIntelligenceInstance) {
    businessIntelligenceInstance = new BusinessIntelligenceSystem()
  }
  return businessIntelligenceInstance
}

export default BusinessIntelligenceSystem
