/**
 * Business Intelligence Reports API Endpoint
 * 
 * Provides REST API for generating and managing BI reports and insights
 */

import { NextRequest, NextResponse } from 'next/server'
import { getBusinessIntelligenceSystem, BIReport } from '@/lib/analytics/business-intelligence'
import { getAuthManager } from '@/lib/security/auth-manager'
import { createApiResponse } from '@/lib/api-response'
import { z } from 'zod'

// Request validation schemas
const ReportGenerateSchema = z.object({
  reportId: z.string().min(1),
  customFilters: z.record(z.any()).optional(),
  format: z.enum(['pdf', 'excel', 'html', 'json']).default('json'),
  includeInsights: z.boolean().default(true),
  emailRecipients: z.array(z.string().email()).optional()
})

const DataMiningJobSchema = z.object({
  name: z.string().min(1).max(100),
  type: z.enum(['pattern_discovery', 'anomaly_detection', 'clustering', 'classification', 'association_rules']),
  config: z.object({
    dataSource: z.string(),
    algorithm: z.string(),
    parameters: z.record(z.any()),
    outputFormat: z.string().default('json')
  })
})

const InsightQuerySchema = z.object({
  category: z.string().optional(),
  severity: z.enum(['low', 'medium', 'high', 'critical']).optional(),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
  timeRange: z.object({
    start: z.string().datetime(),
    end: z.string().datetime()
  }).optional()
})

export async function POST(request: NextRequest) {
  try {
    // Authentication check
    const authHeader = request.headers.get('Authorization')
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return createApiResponse(null, 'Authentication required', 401)
    }

    const token = authHeader.substring(7)
    const authManager = getAuthManager()
    const user = await authManager.verifyToken(token)

    if (!user) {
      return createApiResponse(null, 'Invalid token', 401)
    }

    // Check permissions - only certain roles can generate reports
    if (!['admin', 'super_admin', 'hospital'].includes(user.role)) {
      return createApiResponse(null, 'Insufficient permissions for BI operations', 403)
    }

    // Parse request body
    const body = await request.json()
    const action = body.action

    switch (action) {
      case 'generate_report':
        return await handleGenerateReport(body, user)
      
      case 'start_data_mining':
        return await handleStartDataMining(body, user)
      
      case 'generate_insights':
        return await handleGenerateInsights(body, user)
      
      default:
        return createApiResponse(null, 'Invalid action', 400)
    }

  } catch (error) {
    console.error('BI Reports API error:', error)
    
    return createApiResponse(null, 'BI operation failed', 500, {
      error: process.env.NODE_ENV === 'development' ? (error as Error).message : undefined
    })
  }
}

async function handleGenerateReport(body: any, user: any) {
  // Validate report generation request
  const validationResult = ReportGenerateSchema.safeParse(body)

  if (!validationResult.success) {
    return createApiResponse(null, 'Invalid report generation request', 400, {
      errors: validationResult.error.errors
    })
  }

  const reportRequest = validationResult.data

  // Generate report
  const biSystem = getBusinessIntelligenceSystem()
  const result = await biSystem.generateReport(reportRequest.reportId, reportRequest.customFilters)

  // Log report generation
  console.log(`Report generated by user ${user.id}:`, {
    reportId: reportRequest.reportId,
    format: reportRequest.format,
    executionTime: result.metadata.executionTime,
    recordCount: result.metadata.recordCount
  })

  return createApiResponse({
    success: true,
    data: {
      reportId: reportRequest.reportId,
      report: result.report,
      metadata: result.metadata,
      format: reportRequest.format
    },
    metadata: {
      generatedAt: result.metadata.generatedAt.toISOString(),
      generatedBy: user.id
    }
  })
}

async function handleStartDataMining(body: any, user: any) {
  // Only super admins can start data mining jobs
  if (user.role !== 'super_admin') {
    return createApiResponse(null, 'Data mining requires super admin privileges', 403)
  }

  // Validate data mining request
  const validationResult = DataMiningJobSchema.safeParse(body)

  if (!validationResult.success) {
    return createApiResponse(null, 'Invalid data mining request', 400, {
      errors: validationResult.error.errors
    })
  }

  const jobRequest = validationResult.data

  // Start data mining job
  const biSystem = getBusinessIntelligenceSystem()
  const jobId = await biSystem.startDataMiningJob(jobRequest)

  return createApiResponse({
    success: true,
    data: {
      jobId,
      name: jobRequest.name,
      type: jobRequest.type,
      status: 'pending'
    },
    metadata: {
      startedAt: new Date().toISOString(),
      startedBy: user.id
    }
  })
}

async function handleGenerateInsights(body: any, user: any) {
  // Parse insight generation request
  const { category, timeRange } = body

  let parsedTimeRange
  if (timeRange) {
    parsedTimeRange = {
      start: new Date(timeRange.start),
      end: new Date(timeRange.end)
    }
  }

  // Generate insights
  const biSystem = getBusinessIntelligenceSystem()
  const insights = await biSystem.generateInsights(category, parsedTimeRange)

  return createApiResponse({
    success: true,
    data: {
      insights: insights.map(insight => ({
        id: insight.id,
        type: insight.type,
        category: insight.category,
        title: insight.title,
        description: insight.description,
        severity: insight.severity,
        confidence: insight.confidence,
        actionItems: insight.actionItems,
        createdAt: insight.createdAt
      })),
      count: insights.length
    },
    metadata: {
      generatedAt: new Date().toISOString(),
      generatedBy: user.id,
      category,
      timeRange: parsedTimeRange
    }
  })
}

export async function GET(request: NextRequest) {
  try {
    // Authentication check
    const authHeader = request.headers.get('Authorization')
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return createApiResponse(null, 'Authentication required', 401)
    }

    const token = authHeader.substring(7)
    const authManager = getAuthManager()
    const user = await authManager.verifyToken(token)

    if (!user) {
      return createApiResponse(null, 'Invalid token', 401)
    }

    // Check permissions
    if (!authManager.hasPermission(user, 'read:analytics')) {
      return createApiResponse(null, 'Insufficient permissions', 403)
    }

    // Parse query parameters
    const url = new URL(request.url)
    const action = url.searchParams.get('action')
    const id = url.searchParams.get('id')

    switch (action) {
      case 'list_reports':
        return await handleListReports(user)
      
      case 'get_report':
        if (!id) {
          return createApiResponse(null, 'Report ID required', 400)
        }
        return await handleGetReport(user, id)
      
      case 'list_insights':
        return await handleListInsights(user, url.searchParams)
      
      case 'get_data_mining_job':
        if (!id) {
          return createApiResponse(null, 'Job ID required', 400)
        }
        return await handleGetDataMiningJob(user, id)
      
      case 'system_stats':
        return await handleGetSystemStats(user)
      
      default:
        return await handleListReports(user)
    }

  } catch (error) {
    console.error('BI Reports query API error:', error)
    
    return createApiResponse(null, 'Failed to retrieve BI data', 500)
  }
}

async function handleListReports(user: any) {
  const biSystem = getBusinessIntelligenceSystem()
  const reports = await biSystem.listReports()

  // Filter reports based on user permissions
  const filteredReports = reports.filter(report => {
    // Super admins can see all reports
    if (user.role === 'super_admin') return true
    
    // Admins can see operational and strategic reports
    if (user.role === 'admin') {
      return ['operational', 'strategic', 'clinical'].includes(report.category)
    }
    
    // Hospitals can see operational and clinical reports
    if (user.role === 'hospital') {
      return ['operational', 'clinical'].includes(report.category)
    }
    
    return false
  })

  return createApiResponse({
    success: true,
    data: {
      reports: filteredReports.map(report => ({
        id: report.id,
        name: report.name,
        description: report.description,
        category: report.category,
        type: report.type,
        schedule: report.schedule,
        lastGenerated: report.lastGenerated,
        nextScheduled: report.nextScheduled,
        isActive: report.isActive
      })),
      count: filteredReports.length
    },
    metadata: {
      timestamp: new Date().toISOString(),
      requestedBy: user.id
    }
  })
}

async function handleGetReport(user: any, reportId: string) {
  const biSystem = getBusinessIntelligenceSystem()
  
  // Generate the report
  const result = await biSystem.generateReport(reportId)

  return createApiResponse({
    success: true,
    data: {
      reportId,
      report: result.report,
      metadata: result.metadata
    },
    metadata: {
      timestamp: new Date().toISOString(),
      requestedBy: user.id
    }
  })
}

async function handleListInsights(user: any, searchParams: URLSearchParams) {
  // Parse query parameters
  const queryParams = Object.fromEntries(searchParams.entries())
  
  // Convert numeric parameters
  if (queryParams.limit) queryParams.limit = parseInt(queryParams.limit)
  if (queryParams.offset) queryParams.offset = parseInt(queryParams.offset)

  const validationResult = InsightQuerySchema.safeParse(queryParams)

  if (!validationResult.success) {
    return createApiResponse(null, 'Invalid query parameters', 400, {
      errors: validationResult.error.errors
    })
  }

  const query = validationResult.data

  const biSystem = getBusinessIntelligenceSystem()
  const insights = await biSystem.getInsights(query.category, query.severity)

  // Apply pagination
  const paginatedInsights = insights.slice(query.offset, query.offset + query.limit)

  return createApiResponse({
    success: true,
    data: {
      insights: paginatedInsights.map(insight => ({
        id: insight.id,
        type: insight.type,
        category: insight.category,
        title: insight.title,
        description: insight.description,
        severity: insight.severity,
        confidence: insight.confidence,
        actionItems: insight.actionItems.length,
        createdAt: insight.createdAt
      })),
      count: paginatedInsights.length
    },
    pagination: {
      total: insights.length,
      limit: query.limit,
      offset: query.offset
    },
    metadata: {
      timestamp: new Date().toISOString(),
      requestedBy: user.id,
      filters: {
        category: query.category,
        severity: query.severity
      }
    }
  })
}

async function handleGetDataMiningJob(user: any, jobId: string) {
  // Only super admins can view data mining jobs
  if (user.role !== 'super_admin') {
    return createApiResponse(null, 'Data mining access requires super admin privileges', 403)
  }

  const biSystem = getBusinessIntelligenceSystem()
  const job = await biSystem.getDataMiningJob(jobId)

  if (!job) {
    return createApiResponse(null, 'Data mining job not found', 404)
  }

  return createApiResponse({
    success: true,
    data: {
      job: {
        id: job.id,
        name: job.name,
        type: job.type,
        status: job.status,
        config: job.config,
        results: job.results,
        createdAt: job.createdAt,
        completedAt: job.completedAt,
        error: job.error
      }
    },
    metadata: {
      timestamp: new Date().toISOString(),
      requestedBy: user.id
    }
  })
}

async function handleGetSystemStats(user: any) {
  // Only admins can view system stats
  if (!['admin', 'super_admin'].includes(user.role)) {
    return createApiResponse(null, 'System stats require admin privileges', 403)
  }

  const biSystem = getBusinessIntelligenceSystem()
  const stats = biSystem.getSystemStats()

  return createApiResponse({
    success: true,
    data: {
      systemStats: stats,
      timestamp: new Date().toISOString()
    },
    metadata: {
      requestedBy: user.id
    }
  })
}

// Export report (PDF, Excel, etc.)
export async function PUT(request: NextRequest) {
  try {
    // Authentication check
    const authHeader = request.headers.get('Authorization')
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return createApiResponse(null, 'Authentication required', 401)
    }

    const token = authHeader.substring(7)
    const authManager = getAuthManager()
    const user = await authManager.verifyToken(token)

    if (!user) {
      return createApiResponse(null, 'Invalid token', 401)
    }

    // Parse request body
    const body = await request.json()
    const { reportId, format, customFilters } = body

    if (!reportId || !format) {
      return createApiResponse(null, 'Report ID and format required', 400)
    }

    // Generate report
    const biSystem = getBusinessIntelligenceSystem()
    const result = await biSystem.generateReport(reportId, customFilters)

    // In a real implementation, you would convert the report to the requested format
    // For now, we'll return the JSON data with format information
    const exportData = {
      format,
      report: result.report,
      metadata: result.metadata,
      exportedAt: new Date().toISOString(),
      exportedBy: user.id
    }

    return createApiResponse({
      success: true,
      data: exportData,
      metadata: {
        format,
        size: JSON.stringify(exportData).length,
        exportedAt: new Date().toISOString()
      }
    })

  } catch (error) {
    console.error('Report export API error:', error)
    
    return createApiResponse(null, 'Report export failed', 500)
  }
}
